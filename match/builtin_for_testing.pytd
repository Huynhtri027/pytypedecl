# This is excerpted from //third_party/py/pytypedecl/builtins/__builtins__.pytd
# as a minimal set of builtins to simplify debugging.
# Items have been added as needed, and some class definitions are incomplete.

False: bool
True: bool
NotImplemented: NotImplementedType
None: NoneType

class object:
    def __init__(self, ...)

class NotImplementedType:
    pass

class NoneType:
    pass

class basestring:
    pass

class str(basestring):
    def __init__(self, object)
    def __init__(self)
    def __add__(self, y: str or bytearray) -> str
    def __add__(self, y: unicode) -> unicode
    def __eq__(self, y: str or bytearray) -> bool

class unicode(basestring):
    def __init__(self, string, ...)
    def __init__(self)
    def __add__(self, y: str or unicode or bytearray) -> unicode
    def __eq__(self, y: str or unicode or bytearray) -> bool

class bytearray:
    def __init__(self, iterable_of_ints)
    def __init__(self)
    def __add__(self, y: str or bytearray) -> bytearray
    def __eq__(self, y: str or bytearray) -> bool
    def append(self, int: str or int) -> NoneType

class <T> list:
    def __init__(self):
      self := list<nothing>  # TODO: restore?
    def <A> __add__(self, y: list<A>) -> list<T or A>
    def __getitem__(self, y) -> T
    def __setitem__(self, i: int, y) -> NoneType
    # TODO: restore the original version of append (and __init__
    #                  above) when := is handled. See testTwoLists
    # def <A> append(self, object: A) -> NoneType:
    #   self := list<T or A>
    def append(self, value: T) -> NoneType  # TODO: revert to original
    def remove(self, value: T) -> NoneType

class <K, V> dict:
    def __init__(self, p0)
    def __init__(self)
    def __eq__(self, y: dict) -> bool
    def __getitem__(self, y: K) -> V
    def <K2, V2> __setitem__(self, i: K2, y: V2) -> NoneType:
      self := dict<K or K2, V or V2>

class bool:
    def __init__(self, x)
    def __init__(self)

class int:
    def __init__(self, x: int or float, ...)
    def __init__(self)
    def __add__(self, y: int) -> int
    def __radd__(self, y: int) -> int
    def __eq__(self, y) -> bool

class float:
    def __init__(self, x: int or float)
    def __init__(self)
    def __add__(self, y: int or float) -> float
    def __radd__(self, y: int or float) -> float
    def __eq__(self, y: int or float) -> bool

class xrange:
    def __init__(self, stop: int, ...)
    def __iter__(self) -> rangeiterator

class rangeiterator:
    def __iter__(self) -> rangeiterator
    def next(self) -> int
